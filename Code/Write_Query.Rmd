---
title: "Write_Query"
output: html_document
date: "2025-09-04"
---

```{r setup, include=FALSE}


library(data.table)
library(digest)
library(dplyr)
library(fs)
library(here)
library(httr2)
library(jsonlite)
library(purrr)
library(readr)
library(quanteda)
library(readxl)
library(stringdist)
library(stringr)
library(tibble)
library(tidyr)
library(tidytext)
library(spacyr)
library(stringi)
library(ggplot2)
library(scales)
library(conflicted)
library(reticulate)
library(spacyr)
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(tibble)
library(httr2)
library(fs)
library(arrow)

conflicted::conflicts_prefer(dplyr::lag)


options(scipen = 999)
`%||%` <- function(a,b) if (is.null(a) || (is.atomic(a) && length(a)==1 && is.na(a))) b else a
options(mc.cores = 7)


# Sys.setenv(RETICULATE_PYTHON="~/.virtualenvs/rgee_final/bin/python")
# use_python("~/.virtualenvs/rgee_final/bin/python", required = TRUE)
# cfg <- py_config()
# 
# system2(cfg$python, c("-m","spacy","download","en_core_web_sm"))
 
spacy_initialize(python_executable = cfg$python, model = "en_core_web_sm")



```


```{r}


collapse_phrase_acronym_echo <- function(x){ x <- gsub("\\b([A-Za-z][A-Za-z\\s]{2,}?)(\\s*\\(([A-Z]{2,6})\\))","\\1",x,perl=TRUE); gsub("\\b([A-Z]{2,6})\\s*\\(\\1\\)","\\1",x,perl=TRUE) }
strip_admin_tails <- function(x){ x <- gsub("\\b(PERIOD OF PERFORMANCE|PRIME CONTRACT NO\\.|SUBCONTRACT NO\\.|MODIFICATION NO\\.)\\b[^\\.;\\n]*","",x,perl=TRUE); gsub("\\b(FUNDED BY|REQUESTED BY)\\b[^\\.;\\n]*","",x,perl=TRUE) }
drop_serials_ids_dates <- function(x){ x <- gsub("\\b[A-Z]{2,}\\d[\\w\\-\\.]{4,}\\b","",x,perl=TRUE); x <- gsub("\\b\\d{4}\\b","",x,perl=TRUE); x <- gsub("\\b(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)[A-Z]*\\s+\\d{1,2},?\\s*\\d{4}\\b","",x,perl=TRUE); gsub("\\bfrom\\s+[^\\s]+\\s+to\\s+[^\\s]+","",x,ignore.case=TRUE,perl=TRUE) }
dedup_ngrams <- function(x){ w <- unlist(strsplit(x,"\\s+")); if (length(w)<6) return(str_squish(x)); res <- w[1]; for(i in 2:length(w)){ prev5 <- tail(res,5); cand <- w[i]; if (length(prev5) && tail(prev5,1)==cand) next; res <- c(res,cand) }; str_squish(paste(res,collapse=" ")) }
preclean_text <- function(x){ x %>% collapse_phrase_acronym_echo() %>% strip_admin_tails() %>% drop_serials_ids_dates() %>% dedup_ngrams() %>% str_squish() }
split_to_units <- function(text){ s <- unlist(stringi::stri_split_boundaries(text,type="sentence"),use.names=FALSE); s <- s[nzchar(s)]; s <- vapply(s, preclean_text, character(1)); unique(s[nzchar(s)]) }

```


```{r}



build_global_idf <- function(text_vec){
  text_vec <- as.character(text_vec); text_vec[is.na(text_vec)] <- ""
  text_vec <- vapply(text_vec, preclean_text, character(1))
  toks <- tokens(text_vec, remove_punct=TRUE, remove_numbers=TRUE)
  toks <- tokens_tolower(toks)
  toks <- tokens_remove(toks, stopwords("en"))
  dfm  <- dfm(toks)
  N    <- ndoc(dfm); df <- Matrix::colSums(dfm>0)
  idf  <- log((N+1)/(df+1))
  structure(as.numeric(idf), names = featnames(dfm))
}
idf_path <- here("Data","TF_IDF","idf_vocab.rds")
if (!fs::file_exists(idf_path)) { idf_vocab <- build_global_idf(subcontracts$expanded_description); fs::dir_create(fs::path_dir(idf_path)); saveRDS(idf_vocab,idf_path) }
idf_vocab <- readRDS(idf_path)


```


```{r}


admin_penalty_vec <- function(x){
  nchar_x <- nchar(x)
  up_ratio <- ifelse(nchar_x>0, vapply(strsplit(x,""), function(cs) sum(cs %in% LETTERS), numeric(1))/nchar_x, 0)
  dig_sym  <- str_count(x,"[0-9]")+str_count(x,"[-_/\\.]")
  dates    <- str_count(x,"\\b(19|20)\\d{2}\\b|\\bjan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec\\b")
  id_like  <- str_count(x,"\\b[A-Z]{2,}\\d[\\w\\-]{3,}\\b")
  enum_p   <- str_count(x,",")+str_count(x,";")
  0.6*pmin(up_ratio,1)+0.1*pmin(dig_sym/6,1)+0.1*pmin(dates,3)/3+0.1*pmin(id_like,3)/3+0.1*pmin(enum_p,5)/5
}
verbiness_spacy <- function(sents){
  parsed <- spacy_parse(sents, pos=TRUE, tag=FALSE, entity=FALSE, dependency=FALSE)
  if (!nrow(parsed)) return(rep(0,length(sents)))
  agg <- parsed |> group_by(doc_id) |> summarise(n_verbs=sum(pos=="VERB",na.rm=TRUE), n_toks=n(), has_obj=any(lag(pos)=="VERB" & pos=="NOUN",na.rm=TRUE), .groups="drop")
  score <- (agg$n_verbs/pmax(agg$n_toks,1))+ifelse(agg$has_obj,0.3,0)
  order_ids <- as.character(seq_along(sents)); idx <- match(order_ids, agg$doc_id)
  res <- numeric(length(sents)); res[!is.na(idx)] <- score[idx[!is.na(idx)]]; res
}
tfidf_sentences <- function(sents, idf_vocab){
  toks <- tokens(sents, remove_punct=TRUE, remove_numbers=TRUE)
  toks <- tokens_tolower(toks)
  toks <- tokens_remove(toks, stopwords("en"))
  dfm_s <- dfm(toks); feats <- featnames(dfm_s)
  common <- intersect(feats, names(idf_vocab)); if (!length(common)) return(rep(0,nrow(dfm_s)))
  dfm_s <- dfm_s[, common, drop=FALSE]; as.numeric(dfm_s %*% idf_vocab[common])
}
assemble_ranked <- function(sentences, scores, max_chars=250, max_units=3){
  if (!length(sentences)) return("")
  ord <- order(scores, decreasing=TRUE); selected <- character(0); used <- 0L
  for (i in ord){ cand <- sentences[i]; if (!nzchar(cand)) next; add <- ifelse(length(selected)>0,1L,0L)+nchar(cand); if (used+add>max_chars) next; selected <- c(selected,cand); used <- used+add; if (length(selected)>=max_units || used>=max_chars-1L) break }
  if (!length(selected)) { longest <- sentences[which.max(nchar(sentences))]; return(str_squish(substr(longest,1L,max_chars))) }
  str_squish(substr(paste(selected,collapse=" "),1L,max_chars))
}


```

```{r}
split_sentences_df <- function(text_vec){
  text_vec <- vapply(text_vec, preclean_text, character(1))
  ss <- stringi::stri_split_boundaries(text_vec, type="sentence")
  row_id <- rep(seq_along(ss), lengths(ss))
  sentences <- unlist(ss, use.names=FALSE)
  keep <- nzchar(sentences)
  data.frame(row_id=row_id[keep], sentence=vapply(sentences[keep], preclean_text, character(1)), stringsAsFactors=FALSE)
}
make_psc_query_fast <- function(df, subawardee_col="subawardee_name", expanded_col="expanded_description", max_chars=250, idf_vocab=get("idf_vocab", envir=.GlobalEnv, inherits=TRUE)){
  desc <- tidyr::replace_na(as.character(df[[expanded_col]]), "")
  suba <- tidyr::replace_na(as.character(df[[subawardee_col]]), "")
  desc_clean <- vapply(desc, preclean_text, character(1))
  prefixes <- ifelse(nzchar(suba), paste0(suba, ": "), ""); rooms <- pmax(0L, max_chars - nchar(prefixes))
  sent_df <- split_sentences_df(desc)
  if (!nrow(sent_df)) return(mutate(df, psc_query_250=str_squish(substr(paste0(prefixes,desc_clean),1L,max_chars))))
  vscore <- verbiness_spacy(sent_df$sentence)
  apen   <- admin_penalty_vec(sent_df$sentence)
  len    <- nchar(sent_df$sentence); lbon <- scales::rescale(pmax(0, pmin(len,160)-40), to=c(0,0.15))
  tfidf  <- tfidf_sentences(sent_df$sentence, idf_vocab)
  sent_df$score <- 0.8*tfidf + 1.0*vscore - 0.7*apen + 0.3*lbon
  row_splits <- split(seq_len(nrow(sent_df)), sent_df$row_id)
  assemble_row <- function(j){ ix <- row_splits[[j]]; assembled <- assemble_ranked(sent_df$sentence[ix], sent_df$score[ix], max_chars=rooms[j], max_units=3); if (!nzchar(assembled)) str_squish(substr(desc_clean[j],1L,rooms[j])) else assembled }
  assembled <- vapply(seq_along(row_splits), assemble_row, character(1))
  out <- str_squish(substr(paste0(prefixes,assembled),1L,max_chars))
  mutate(df, psc_query_250=out)
}


```


```{r}
subcontracts_expanded <- make_psc_query_fast(subcontracts_expanded)

test <- make_psc_query(test)

out <- test %>% 
  select(expanded_description, psc_query_250) %>%  
  mutate(nch = nchar(psc_query_250)) %>% 
  filter(nch >=245) %>% 
  head(50)

write.csv(out, "out.csv")


```

```{r}

rowkey_text_dedupe    <- rowkey_text_dedupe    %>% mutate(pair_key = as.character(pair_key))
subcontracts_250query <- subcontracts_250query %>% mutate(pair_key = as.character(pair_key))


dup_keys <- rowkey_text_dedupe %>%
  distinct(pair_key, subawardee_name, subaward_description) %>%
  add_count(pair_key, name = "n_pairs_for_key") %>%
  filter(n_pairs_for_key > 1) %>%
  transmute(pair_key_chr = pair_key)

dup_rows_ranked <- rowkey_text_dedupe %>%
  mutate(pair_key_chr = pair_key) %>%                                     # already character
  semi_join(dup_keys, by = "pair_key_chr") %>%
  arrange(pair_key_chr, subawardee_name, subaward_description, row_id) %>%
  group_by(pair_key_chr, subawardee_name, subaward_description) %>%
  slice_head(n = 1) %>%
  ungroup() %>%
  group_by(pair_key_chr) %>%
  mutate(suffix_idx = dplyr::row_number()) %>%
  ungroup() %>%
  mutate(
    new_pair_key = if_else(
      suffix_idx == 1L,                 # first keeps original (unsuffixed)
      pair_key_chr,
      paste0(pair_key_chr, "~", stringr::str_pad(suffix_idx, 2, pad = "0"))
    )
  )


pairkey_alias <- dup_rows_ranked %>%
  filter(new_pair_key != pair_key_chr) %>%
  transmute(
    original_pair_key   = pair_key_chr,
    new_pair_key,
    subawardee_name,
    subaward_description
  )

rows_to_update_verbose <- rowkey_text_dedupe %>%
  inner_join(
    dup_rows_ranked %>%
      select(pair_key_chr, subawardee_name, subaward_description, suffix_idx, new_pair_key),
    by = c("pair_key" = "pair_key_chr", "subawardee_name", "subaward_description")
  ) %>%
  mutate(will_change = new_pair_key != pair_key)

rows_to_update <- rows_to_update_verbose %>%
  filter(will_change) %>%
  distinct(row_id, new_pair_key)


rowkey_text_fixed <- rowkey_text_dedupe %>%
  left_join(rows_to_update, by = "row_id") %>%
  mutate(pair_key = coalesce(new_pair_key, pair_key)) %>%
  select(-new_pair_key)


new_key_inputs <- dup_rows_ranked %>%
  filter(new_pair_key != pair_key_chr) %>%
  select(pair_key = new_pair_key, subawardee_name, subaward_description)

# If your writer wants 'expanded_description', map the column name:
new_key_min_df <- new_key_inputs %>%
  rename(expanded_description = subaward_description)

# run the dictionary expansion 
# run the psc query builder

new_key_queries <- make_psc_query_fast(
  new_key_min_df,
  subawardee_col = "subawardee_name",
  expanded_col   = "expanded_description",
  max_chars      = 250
) %>%
  select(pair_key, psc_query_250)


# bind into the query df 

subcontracts_250query_fixed <- bind_rows(
  subcontracts_250query,
  new_key_queries %>% anti_join(subcontracts_250query, by = "pair_key")
) %>%
  distinct(pair_key, .keep_all = TRUE)

# check 

qa <- list(
  num_dup_keys_detected = n_distinct(dup_rows_ranked$pair_key_chr),
  num_new_keys_created  = nrow(new_key_queries),
  row_updates           = nrow(rows_to_update),
  total_pairs_before    = n_distinct(rowkey_text_dedupe$subawardee_name, rowkey_text_dedupe$subawardee_description),
  total_pairs_after     = n_distinct(rowkey_text_fixed$subawardee_name, rowkey_text_fixed$subawardee_description),
  keys_unique_in_psc_tbl= nrow(subcontracts_250query_fixed) == n_distinct(subcontracts_250query_fixed$pair_key)
)
print(qa)

dup_rows_ranked %>%
  count(pair_key_chr, subawardee_name, subawardee_description) %>%
  filter(n > 1)
# Expect 0
dup_rows_ranked %>%
  count(new_pair_key) %>%
  filter(n > 1)
# Expect 0
before_pairs <- n_distinct(rowkey_text_dedupe$subawardee_name, rowkey_text_dedupe$subawardee_description)
after_pairs  <- rowkey_text_fixed %>% n_distinct(subawardee_name, subawardee_description)
stopifnot(before_pairs == after_pairs)


dup_rows_ranked %>%
  filter(new_pair_key != pair_key_chr) %>%
  distinct(new_pair_key) %>%
  inner_join(subcontracts_250query %>% distinct(pair_key), by = c("new_pair_key" = "pair_key")) %>%
  nrow() == 0
# Expect TRUE


try %>%  
  distinct(subawardee_name, subaward_description) %>%  
  summarise(ndist = n())

try %>%  
  distinct(pair_key) %>%  
  summarise(ndist = n())

rowkey_text_dedupe %>%  
  distinct(subawardee_name, subaward_description) %>%  
  summarise(ndist = n())



# 1) How many keys vs how many pairs in the FIXED table?
n_keys_fixed  <- dplyr::n_distinct(rowkey_text_fixed$pair_key)
n_pairs_fixed <- dplyr::n_distinct(rowkey_text_fixed$subawardee_name,
                                   rowkey_text_fixed$subaward_description)
n_keys_fixed; n_pairs_fixed  # these should be equal

# 2) Any key still has multiple distinct (name, desc)?
rowkey_text_fixed %>%
  dplyr::group_by(pair_key) %>%
  dplyr::summarise(n_pairs = dplyr::n_distinct(subawardee_name, subaward_description), .groups="drop") %>%
  dplyr::filter(n_pairs != 1)  # expect 0 rows

# 3) Any (name, desc) still maps to multiple keys?
rowkey_text_fixed %>%
  dplyr::group_by(subawardee_name, subaward_description) %>%
  dplyr::summarise(n_keys = dplyr::n_distinct(pair_key), .groups="drop") %>%
  dplyr::filter(n_keys != 1)  # expect 0 rows



outdir <- here::here("Data","Join_Keys")
dir_create(outdir, recurse = TRUE)

# list of objects to save with "_fixed" suffix
objs_to_save <- list(
  dup_keys                   = dup_keys,
  dup_rows_ranked            = dup_rows_ranked,
  pairkey_alias              = pairkey_alias,
  rows_to_update_verbose     = rows_to_update_verbose,
  rows_to_update             = rows_to_update,
  rowkey_text_fixed          = rowkey_text_fixed,
  new_key_inputs             = new_key_inputs
)

# save each one as RDS with "_fixed" in the filename
for (nm in names(objs_to_save)) {
  obj <- objs_to_save[[nm]]
  saveRDS(obj, file = file.path(outdir, paste0(nm, "_fixed.rds")))
}




```




