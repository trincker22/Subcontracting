---
title: "Subcontracting"
output: html_document
date: "2025-08-15"
---



```{r}
rm(list = ls())


```


```{r setup, include=FALSE}


library(tidyverse)
library(haven)
library(readxl)
library(readr)
library(jsonlite)
library(purrr)
library(lubridate)
library(quanteda)  
library(quanteda.textmodels)
library(here)
library(tokenizers)
library(topicmodels)
library(syuzhet)
library(caret)
library(irr)
library(SnowballC)
library(ellmer)
library(data.table)
library(e1071)
library(randomForest)
library(glmnet)
library(ellmer)
library(purrr)
library(stringr)
library(glue)
library(digest)
library(readr)    
library(tibble)
library(uuid)
library(ellmer)
library(here)
options(scipen = 999)

sub <- read_rds(here("subcontracts.RDS"))

NAICS <- read_excel(here("NAICS.xlsx"))


sub <- left_join(sub, NAICS, 
       join_by(naics_code)) %>% 
       mutate(year = year(date(prime_date)))



twos <- sub %>% 
  select(product_or_service_code_descript, subaward_description, naics_title, prime_id_num)


```


```{r}


# ----------------------------------------------------
# Data Prep
# ----------------------------------------------------

summary_data_all <- sub %>%
  group_by(year, naics_code) %>%
  summarise(
    num_contracts = n(),
    avg_contract_value = mean(nom_g, na.rm = TRUE),
    total_contract_value = sum(nom_g, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  left_join(NAICS %>%
              select(naics_code, naics_title),
            join_by(naics_code))

top_5_naics_value <- summary_data_all %>%
  group_by(naics_title) %>%
  summarize(total_value = sum(total_contract_value)) %>%
  arrange(desc(total_value)) %>%
  slice(1:5) %>%
  pull(naics_title)

filtered_summary_top5_value <- summary_data_all %>%
  filter(naics_title %in% top_5_naics_value)


grouped_data_for_shares <- summary_data_all %>%
  mutate(naics_group = ifelse(naics_title %in% top_5_naics_value, naics_title, "Other")) %>%
  group_by(year, naics_group) %>%
  summarise(
    num_contracts_grouped = sum(num_contracts), # Use sum(num_contracts) here
    total_contract_value_grouped = sum(total_contract_value), # Use sum(total_contract_value) here
    .groups = 'drop'
  )


yoy_change_data <- filtered_summary_top5_value %>%
  group_by(naics_title) %>%
  arrange(year) %>%
  mutate(
    yoy_num_contracts = ((num_contracts - lag(num_contracts)) / lag(num_contracts)) * 100,
    yoy_total_contract_value = ((total_contract_value - lag(total_contract_value)) / lag(total_contract_value)) * 100
  ) %>%
  ungroup()

# ----------------------------------------------------
# Plotting 
# ----------------------------------------------------

sub %>%
  group_by(year) %>%
  count() %>%
  ggplot(aes(x = year, y = n)) +
  geom_col() +
  labs(
    title = "Total Number of Contracts Per Year",
    x = "Year",
    y = "Number of Contracts"
  ) +
  theme_minimal()

sub %>% 
  group_by(year) %>% 
  summarise(value_year = sum(nom_g)) %>% 
  ggplot(aes(x = factor(year), y = value_year)) +
  geom_bar(stat= "identity") + 
  labs(
    title = "Total Value of Contracts Per Year",
    x = "Year",
    y = "Total Contract Value ($)"
  ) +
  scale_y_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) + # Format y-axis to billions
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


yoy_change_data %>%
  filter(year > min(year)) %>% # Filter out the first year with NA YOY change
  ggplot(aes(x = year, y = yoy_num_contracts, color = naics_title, group = naics_title)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Year-over-Year Percentage Change in Number of Contracts (Top 5 NAICS)",
    x = "Year",
    y = "Year-over-Year % Change",
    color = "NAICS Industry Title"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

yoy_change_data %>%
  filter(year > min(year)) %>% # Filter out the first year with NA YOY change
  ggplot(aes(x = year, y = yoy_total_contract_value, color = naics_title, group = naics_title)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Year-over-Year Percentage Change in Contract Value (Top 5 NAICS)",
    x = "Year",
    y = "Year-over-Year % Change",
    color = "NAICS Industry Title"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")


ggplot(filtered_summary_top5_value, aes(x = year, y = num_contracts, color = naics_title, group = naics_title)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Number of Contracts for Top 5 NAICS Industries Over Time",
    x = "Year",
    y = "Number of Contracts",
    color = "NAICS Industry Title"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")


ggplot(filtered_summary_top5_value, aes(x = year, y = avg_contract_value, color = naics_title, group = naics_title)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Average Contract Value for Top 5 NAICS Industries Over Time",
    x = "Year",
    y = "Average Contract Value",
    color = "NAICS Industry Title"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot(grouped_data_for_shares, aes(x = factor(year), y = num_contracts_grouped, fill = naics_group)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(
    title = "Share of Contract Number by Year (Top 5 NAICS vs. Other)",
    x = "Year",
    y = "Share of Contracts",
    fill = "NAICS Industry Group"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_fill_brewer(palette = "Paired") +
  scale_y_continuous(labels = scales::percent)


ggplot(grouped_data_for_shares, aes(x = factor(year), y = total_contract_value_grouped, fill = naics_group)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(
    title = "Share of Contract Value by Year (Top 5 NAICS vs. Other)",
    x = "Year",
    y = "Share of Contract Value",
    fill = "NAICS Industry Group"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_fill_brewer(palette = "Paired") +
  scale_y_continuous(labels = scales::percent)



```

```{r}

chat <- ellmer::chat_google_gemini()

contracts <- sub %>% 
  mutate( 
    obs_id = prime_id_num, 
    broad_cat = product_or_service_code_descript, 
    specific_desc = subaward_description, 
    naics = naics_title
    ) %>% 
  select(obs_id, broad_cat, specific_desc, naics)

prompt_readable <- function(broad, specific) {
  glue(
"{{
  \"task\": \"rewrite_to_plain_english\",
  \"schema\": {{
    \"returned_text\": \"string\",
    \"notes\": \"string\"
  }},
  \"instructions\": \"You are given a general contract category and a specific subaward description. 
  If the description is already human-readable, return it unchanged. 
  If it is code-like or obscure, return a brief plain-English description. 
  Be conservative: no hallucinated details; if in doubt, summarize functionally.\",
  \"category\": \"{broad}\",
  \"description\": \"{specific}\",
  \"output_format\": \"JSON with fields returned_text, notes\"
}}")
}

prompt_relation <- function(broad, specific) {
  glue(
"{{
  \"task\": \"relation_classification\",
  \"schema\": {{
    \"relation\": \"enum[same, subset, unrelated, unclear]\",
    \"rationale\": \"string\"
  }},
  \"instructions\": \"Classify the relationship between the broad category and the subtask.
   same = equivalent meaning; subset = subtask is a specialization of the category;
   unrelated = different domains; unclear = insufficient info.\",
  \"category\": \"{broad}\",
  \"subtask\": \"{specific}\",
  \"output_format\": \"JSON with fields relation, rationale\"
}}")
}


call_chat_safe <- function(prompt, max_tries = 5, base_sleep = 2) {
  for (i in seq_len(max_tries)) {
    out <- try(chat$chat(prompt), silent = TRUE)
    if (!inherits(out, "try-error") && is.character(out) && nchar(out) > 0) return(out)
    Sys.sleep(base_sleep * (2^(i-1)) + runif(1, 0, 0.5))
  }
  NA_character_
}

parse_json_relaxed <- function(txt) {
  if (is.na(txt)) return(tibble::tibble(parsed_ok = FALSE))
  m <- str_match(txt, "\\{[\\s\\S]*\\}$")
  json_txt <- if (!is.na(m[,1])) m[,1] else txt
  out <- try(jsonlite::fromJSON(json_txt), silent = TRUE)
  if (inherits(out, "try-error")) tibble(parsed_ok = FALSE) else cbind(parsed_ok = TRUE, as_tibble(out))
}

# batch runner
run_llm_over_df <- function(df, broad_col, specific_col,
                            which_prompt = c("readable", "relation"),
                            batch_size = 20,
                            checkpoint_path = NULL,
                            temperature = 0.0) {
  which_prompt <- match.arg(which_prompt)


  idx <- split(seq_len(nrow(contracts)), ceiling(seq_along(seq_len(nrow(contracts))) / batch_size))

  results <- vector("list", length(idx))
  for (bi in seq_along(idx)) {
    rows <- contracts[idx[[bi]], ]

    # build prompts and call
    prompts <- pmap(rows, function(obs_id, ...) {
      broad <- rows[[broad_col]][rows$obs_id == obs_id]
      spec  <- rows[[specific_col]][rows$obs_id == obs_id]
      if (which_prompt == "readable") prompt_readable(broad, spec) else prompt_relation(broad, spec)
    })

    raw <- map(prompts, ~ call_chat_safe(.x))

    parsed <- map_dfr(raw, parse_json_relaxed)

    out <- tibble(
      obs_id = rows$obs_id,
      raw = raw
    ) %>%
      bind_cols(parsed)

    results[[bi]] <- out

    # checkpoint
    if (!is.null(checkpoint_path) && (bi %% 5 == 0 || bi == length(idx))) {
      write_rds(bind_rows(results[seq_len(bi)]), checkpoint_path)
    }
  }
  bind_rows(results)
}


if (file.exists(here("readable_checkpoint.rds"))) {
  prev_readable <- read_rds(here("readable_checkpoint.rds"))
} else {
  prev_readable <- tibble(obs_id = double())
}

needs_readable <- anti_join(
  contracts %>% select(obs_id, broad_cat, specific_desc),
  prev_readable %>% select(obs_id),
  by = c("obs_id")
)


readable_new <- if (nrow(needs_readable) > 0) {
  run_llm_over_df(
    needs_readable, "broad_cat", "specific_desc",
    which_prompt = "readable",
    batch_size = 20,
    checkpoint_path = "readable_checkpoint.rds"
  )
} else tibble()

readable_all <- bind_rows(
  prev_readable,
  readable_new
) %>% distinct(obs_id, .keep_all = TRUE)

contracts <- contracts %>%
  left_join(
    readable_all %>%
      transmute(obs_id, readable_text = coalesce(returned_text, NA_character_), readable_notes = notes %||% NA_character_),
    by = "obs_id"
  )

if (file.exists(here("relation_checkpoint.rds"))) {
  prev_rel <- read_rds(here("relation_checkpoint.rds"))
} else {
  prev_rel <- tibble(obs_id = character())
}

needs_rel <- anti_join(
  contracts %>% select(obs_id, broad_cat, specific_desc),
  prev_rel %>% select(obs_id),
  by = c("obs_id")
)

rel_new <- if (nrow(needs_rel) > 0) {
  run_llm_over_df(
    needs_rel, "broad_cat", "specific_desc",
    which_prompt = "relation",
    batch_size = 20,
    checkpoint_path = here("relation_checkpoint.rds")
  )
} else tibble()

rel_all <- bind_rows(prev_rel, rel_new) %>% distinct(obs_id, .keep_all = TRUE)

contracts <- contracts %>%
  left_join(
    rel_all %>% transmute(
      obs_id,
      relation = ifelse(parsed_ok, relation, NA_character_),
      relation_rationale = ifelse(parsed_ok, rationale, NA_character_)
    ),
    by = "obs_id"
  )


```

```{r}


```

```{r}


```

```{r}

